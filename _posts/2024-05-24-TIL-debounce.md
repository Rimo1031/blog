---
title: "JavaScript에서의 디바운싱과 쓰로틀링"
excerpt: " "
categories:
  - Programming Language
tags:
  - [JavaScript]
toc: true
toc_sticky: true
# last_modified_at : 2022-04-12T00:30:00
---

디바운싱(debouncing)과 쓰로틀링(throttling)은 프로그래밍 기법의 일종으로, 프로그램의 성능을 최적화하기 위해 사용하는 방법이다. 어떤 개념이나 기술이라기 보다는 코드를 짜는 방법론에 가까운 말인데, 웹 프론트엔드 개발에서 사용할 수 있도록 JavaScript에서 디바운싱과 쓰로틀링을 구현하는 방법을 정리해 보았다.

## 디바운싱 (debouncing)

> 연속적으로 많은 함수가 호출될 때 **마지막에 호출된 함수**만 실행하는 방법

특정 이벤트 핸들러가 짧은 시간 내에 대량으로 호출되는 경우가 있다. 가장 대표적인 예시로 검색어 자동완성 기능을 들 수 있다. 사용자가 검색어를 입력하면 그에 맞는 추천 검색어를 띄워 주는 기능인데, 내부적으로는 input값이 변경될 때마다 그 input값을 참조해 추천 검색어 리스트를 받아오는 API 요청이 발생하고 있을 것이다. 만약 이 이벤트 핸들러에 아무런 최적화가 되어 있지 않다면 사용자가 입력한 값이 변경될 때마다 매번 요청을 하게 된다. 예를 들어, "리액트"라는 검색어를 입력했다고 하자. "리액트"라는 단어를 입력할 동안 input창은 아래와 같이 바뀔 것이다.

> "ㄹ" → "리" → "링" → "리애" → "리액" → "리액ㅌ" → "리액트"

input의 onchange 핸들러는 말 그대로 input에 입력된 값이 변경될 때마다 실행되므로, 추천 검색어 목록을 위한 API 요청이 7번 발생하게 된다. 그런데 여기서 "ㄹ" ~ "리액ㅌ" 단계에서 실행되는 6번의 API 요청은 사실 사용자에게 보여줄 필요가 없는 무의미한 요청이다. 예시는 검색어 자동완성으로 들었지만, 만약 이 API 요청이 ChatGPT나 구글 지도처럼 유료 API를 사용한다면 성능뿐만 아니라 비용적인 측면에서도 문제가 생길 것이다.

이러한 문제점을 예방하기 위해 사용자가 입력을 완성할 때까지 기다린다면 어떨까? 입력이 더 이상 들어오지 않는 시점부터 일정 시간이 지나면 입력을 완성했다고 판단하고, 그 때만 onchange 핸들러를 실행시킬 수 있다면 중간의 무의미한 함수 실행을 방지할 수 있을 것이다.

구체적인 구현 방법은 다음과 같다. `setTimeout`으로 실제 onchange 핸들러 로직이 일정 delay 뒤에 실행되게 하고, onchange 핸들러가 실행되면 가장 먼저 이 타이머를 초기화한다. 이렇게 하면 사용자가 입력을 진행할 때마다 타이머가 초기화되면서 실제 로직이 실행되지 않다가, 입력을 멈추고 일정 시간이 지나면 실제로 원하는 로직을 실행하는 구조를 만들 수 있다.

```javascript
const handleOnChange = (delay = 200) => {
  clearTimeout(debounceTimer)

  const debounceTimer = setTimeout(() => {
    const inputValue = "input 값"
    ...(실제 로직)
  }, delay)
}
```

## 쓰로틀링 (throttling)

> 어떤 함수가 한번 실행되고 나면 **일정 시간동안 재실행을 막는 방법**

디바운싱과 반대로, 연속적인 함수 실행에 대해 첫 번째 시도만 실제로 실행하고 나머지는 무시하는 방법이다. 웹 프론트엔드에서의 예시로는 스크롤 이벤트와 resize 이벤트를 들 수 있다. 양쪽 모두 스크롤 위치나 창 크기가 px단위로 바뀔 때마다 이벤트 핸들러가 실행되기 때문에 매우 많은 함수가 실행되게 되는데, 실제로 실행되어야 하는 로직은 대부분 스크롤이나 resize 이벤트의 발생 자체만을 감지하면 되는 경우가 대부분이다. 이런 경우에는 쓰로틀링을 활용해서 무수한 함수 실행을 막고 일정 간격으로만 실행되도록 최적화할 수 있다.

JavaScript에서는 디바운싱과 동일하게 `setTimeout`을 활용한다. 실제 실행되어야 하는 로직을 일정 간격 이후에 실행되게 하고, 이 간격 사이에 재실행되는 경우에는 실행을 무시한다.

```javascript
let throttleTimer
const throttle = (delay = 200) => {
  // 타이머가 설정되어있으면 무시
  if (throttleTimer) return

  throttleTimer = setTimeout(() => {
    ...(실제 로직)
    throttleTimer = null
  }, delay)
}