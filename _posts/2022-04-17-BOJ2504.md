---
title: "BOJ 2504. 괄호의 값"
excerpt: "주어진 괄호열을 읽고 그 괄호값을 출력하라."
categories: 
  - Problem Solving
tags:
  - Stack
  - Recursion
  - Implementation
toc: true
toc_sticky: true
# last_modified_at : 2022-04-12T00:30:00
---

## 문제 정보

[BOJ 2504. 괄호의 값](https://www.acmicpc.net/problem/2504)

| [solved.ac](https://solved.ac) Tier | Time Limit | Memory Limit |
|:-----------------------------------:|:----------:|:------------:|
| Silver 2                            | 1 s        | 128 MB       |

## 코드
- 제출한 날짜 : 2022.03.25
- 사용 언어 : C++

```cpp
#include <iostream>
#include <stack>
#include <vector>
#include <string>

using namespace std;

int isValid(string str) {
	if (str.length() % 2 == 1) return 0;
	stack<int> s_br;
	stack<int> l_br;
	for (int i=0;i<str.length();i++) {
		char ch = str[i];
		switch (ch) {
			case 40:
				s_br.push(1);
				break;
			case 91:
				l_br.push(1);
				break;
			case 41:
				if (s_br.empty()) return 0;
				s_br.pop();
				break;
			case 93:
				if (l_br.empty()) return 0;
				l_br.pop();
				break;
		}
	}
	if (s_br.empty() && l_br.empty()) return 1;
	return 0;
}

int value(string str) {
	if (!isValid(str)) return 0;
	//str.length == 2 : return 2 or 3
	if (str.length() == 2) {
		if (str.front() == '(') return 2;
		else if (str.front() == '[') return 3;
	}
	/*
	str.length > 2
	str를 올바른 괄호열로 분리
	*/
	stack<int> s_br;
	stack<int> l_br;
	vector<int> bor; // 올바른 괄호열의 경계선
	bor.push_back(-1);
	vector<int> res; // 올바른 괄호열 각각의 값
	int sum = 0;
	//올바른 괄호열끼리 분리

	for (int i=0;i<str.length();i++) {
		switch (str[i]) {
			case '(': // (
				s_br.push(1);
				break;
			case ')': // )
				s_br.pop();
				break;
			case '[': // [
				l_br.push(1);
				break;
			case ']': // ]
				l_br.pop();
				break;
		}
		if (s_br.empty() && l_br.empty()) {
			bor.push_back(i);
		}
	}
	if (bor.size() == 2) {
		if (str.front() == '(') return 2*value(str.substr(1, str.length()-2));
		else if (str.front() == '[') return 3*value(str.substr(1, str.length()-2));		
	}
	//각각 괄호열의 값 계산
	vector<int>::iterator itr;
	for (int i=0;i<bor.size()-1;i++) {
		res.push_back(value(str.substr(bor[i]+1, bor[i+1]-bor[i])));
	}
	for (itr=res.begin();itr!=res.end();itr++) {
		sum += *itr;
	}
	return sum;

}

int main() {
	string input;
	cin >> input;
	cout << value(input);
	return 0;
}
```

1부터 n까지의 수가 들어가 있는 stack `ex`와 실제 수열을 생성하는 데 사용하는 stack `seq`를 선언했다.

입력된 수열을 만들 수 없는 경우 (예외 처리를 해야 하는 경우)는 다음과 같다.
1. 아직 입력된 수를 다 처리하지 않았는데 더 사용할 수가 없는 경우
2. 현재 처리할 수가 다음에 사용할 수 있는 수보다 작은 경우 (다음에 사용할 수 있는 수보다 작은 수는 이미 사용했기 때문에)
3. 현재 처리할 수가 생성된 스택 수열의 top 값과 다른 경우
각각의 경우에 "NO"를 출력하고 종료하게 구현했다.

아직 수열을 생성할 수 있는 경우는 다음과 같다.
1. 현재 처리할 수가 다음에 사용할 수 있는 수보다 크거나 같은 경우
	- 현재 처리할 수까지를 수열 스택에 push하고 마지막 한 개를 pop한다.
2. 현재 처리할 수가 수열 스택의 top과 같은 경우
	- pop만 한 번 해 준다.
각각의 경우에 알맞는 연산을 하도록 구현했다.


## 코드 분석

### 변수
#### `stack<int> ex`
1부터 n까지의 수가 저장된 stack이다. top에 1이, bottom에 n이 저장되어 있고 한번 ex에서 pop된 수는 다시 사용될 수 없다.

#### `stack<int> seq`
수열을 생성할 때 사용하는 stack이다.

#### `int input[n]`
입력받은 정수를 저장하는 배열이다.

### 함수
####  `int main()`

1. `seq`와 `ex`가 모두 비어 있으면 "NO"를 출력한다.

2. `seq`가 비어 있고 `ex`가 비어 있지 않으면 `input[i]`와 `ex.top()`을 비교해 전자가 작으면 "NO"를 출력하고, 후자가 작으면 `input[i]`까지의 수를 하나씩 `ex`에서 pop해 `seq`에 push한다.

3. `seq`가 비어 있지 않고 `ex`가 비어 있으면 `input[i]`와 `seq.top()`을 비교해 다르면 "NO"를 출력하고, 같으면 `seq`에서 pop한다.

4. `seq`와 `ex`가 모두 비어 있지 않으면 2.와 3.의 경우를 모두 확인한다.